/* See COPYRIGHT for copyright information. */

#include <inc/mmu.h>
#include <inc/memlayout.h>
#include <inc/trap.h>

#include <kern/picirq.h>


###################################################################
# exceptions/interrupts
###################################################################

/* TRAPHANDLER defines a globally-visible function for handling a trap.
 * It pushes a trap number onto the stack, then jumps to _alltraps.
 * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
 *
 * You shouldn't call a TRAPHANDLER function from C, but you may
 * need to _declare_ one in C (for instance, to get a function pointer
 * during IDT setup).  You can declare the function with
 *   void NAME();
 * where NAME is the argument passed to TRAPHANDLER.
 */
#define TRAPHANDLER(name, num)						\
	.globl name;		/* define global symbol for 'name' */	\
	.type name, @function;	/* symbol type is function */		\
	.align 2;		/* align function definition */		\
	name:			/* function starts here */		\
	pushl $(num);							\
	jmp _alltraps

/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
 * It pushes a 0 in place of the error code, so the trap frame has the same
 * format in either case.
 */
#define TRAPHANDLER_NOEC(name, num)					\
	.globl name;							\
	.type name, @function;						\
	.align 2;							\
	name:								\
	pushl $0;							\
	pushl $(num);							\
	jmp _alltraps

.text

/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */
TRAPHANDLER_NOEC(divide_err, T_DIVIDE)      // 0	divide error
TRAPHANDLER_NOEC(debug_exception, T_DEBUG)  // 1	debug exception
TRAPHANDLER_NOEC(nmi, T_NMI)                // 2	non-maskable interrupt
TRAPHANDLER_NOEC(breakpoint, T_BRKPT)       // 3	breakpoint
TRAPHANDLER_NOEC(overflow, T_OFLOW)         // 4	overflow
TRAPHANDLER_NOEC(bounds_check, T_BOUND)     // 5	bounds check
TRAPHANDLER_NOEC(illegal_opcode, T_ILLOP)   // 6	illegal opcode
TRAPHANDLER_NOEC(dev_not_avail, T_DEVICE)   // 7	device not available
TRAPHANDLER(double_fault, T_DBLFLT)         // 8	double fault
/* #define T_COPROC  9 */       // reserved (not generated by recent processors)
TRAPHANDLER(invalid_tss, T_TSS)            // 10	invalid task switch segment
TRAPHANDLER(segment_not_present, T_SEGNP)  // 11	segment not present
TRAPHANDLER(stack_exception, T_STACK)      // 12	stack exception
TRAPHANDLER(general_protect, T_GPFLT)      // 13	general protection fault
TRAPHANDLER(page_fault, T_PGFLT)           // 14	page fault
/* #define T_RES    15 */       // reserved
TRAPHANDLER_NOEC(fp_err, T_FPERR)          // 16	floating point error
TRAPHANDLER(alig_check, T_ALIGN)           // 17	aligment check
TRAPHANDLER_NOEC(machine_check, T_MCHK)    // 18	machine check
TRAPHANDLER_NOEC(simd_fp_err, T_SIMDERR)   // 19	SIMD floating point error

TRAPHANDLER_NOEC(irq0, IRQ_OFFSET+0)		// IRQ_TIMER
TRAPHANDLER_NOEC(irq1, IRQ_OFFSET+1)		// IRQ_KBD
TRAPHANDLER_NOEC(irq2, IRQ_OFFSET+2)
TRAPHANDLER_NOEC(irq3, IRQ_OFFSET+3)
TRAPHANDLER_NOEC(irq4, IRQ_OFFSET+4)		// IRQ_SERIAL
TRAPHANDLER_NOEC(irq5, IRQ_OFFSET+5)
TRAPHANDLER_NOEC(irq6, IRQ_OFFSET+6)
TRAPHANDLER_NOEC(irq7, IRQ_OFFSET+7)		// IRQ_SPURIOUS
TRAPHANDLER_NOEC(irq8, IRQ_OFFSET+8)
TRAPHANDLER_NOEC(irq9, IRQ_OFFSET+9)
TRAPHANDLER_NOEC(irq10, IRQ_OFFSET+10)
TRAPHANDLER_NOEC(irq11, IRQ_OFFSET+11)
TRAPHANDLER_NOEC(irq12, IRQ_OFFSET+12)
TRAPHANDLER_NOEC(irq13, IRQ_OFFSET+13)
TRAPHANDLER_NOEC(irq14, IRQ_OFFSET+14)		// IRQ_IDE
TRAPHANDLER_NOEC(irq15, IRQ_OFFSET+15)

TRAPHANDLER_NOEC(_syscall, T_SYSCALL)      // 48	system call

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
	pushl	%ds
	pushl	%es
	pushal

	movw	$GD_KD, %ax
	movw	%ax, %ds
	movw	%ax, %es

	pushl	%esp
	call	trap

.data
.globl isrs
isrs:
	.long divide_err
	.long debug_exception
	.long nmi
	.long breakpoint
	.long overflow
	.long bounds_check
	.long illegal_opcode
	.long dev_not_avail
	.long double_fault
	.long 0			// 9 is reserved
	.long invalid_tss
	.long segment_not_present
	.long stack_exception
	.long general_protect
	.long page_fault
	.long 0			// 15 is reserved
	.long fp_err
	.long alig_check
	.long machine_check
	.long simd_fp_err
.fill 12, 4, 0			// 20~31 is reserved
	.long irq0
	.long irq1
	.long irq2
	.long irq3
	.long irq4
	.long irq5
	.long irq6
	.long irq7
	.long irq8
	.long irq9
	.long irq10
	.long irq11
	.long irq12
	.long irq13
	.long irq14
	.long irq15
	.long _syscall
.fill 0xcf, 4, 0		//  0x31~0xff (0xcf items) is reserved
